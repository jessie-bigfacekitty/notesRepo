# 第一章 操作系统

## 操作系统的基本概念

操作系统（operation system，os) 指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是硬件：中央处理器，内存，输入｜输出设备，提供基本的计算资源。

## 操作系统的角色及功能

1. 作为计算机系统资源的管理者：
    * 处理机管理、存储器管理、文件管理、设备管理
    * 目标：安全、高效
1.2  作为用户和计算机之间的接口：
    * 命令接口： 允许用户直接使用。联机命令接口（交互式命令接口，用户说一句，系统做一句）+脱机命令接口（批处理命令接口，用户说一句，系统做一堆。脚本）
    * 程序接口：允许用户通过程序间接使用，由一组系统调用组成（程序接口=系统调用（广义指令））
     例如： user32.dll在程序中调用可以创建窗口等功能，只能通过程序调用
          Gui: 现代操作系统中最流行的图形用户接口1+2=用户接口目标：方便用户使用作为最接近硬件的层次：目标：实现对硬件机器的拓展通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机？
1.3 操作系统实现了对计算机资源的扩充：例如虚拟技术。

## 操作系统的基本特征

1. 并发：操作系统的并发性指计算机中同时存在着多个运行着的程序；并发：指2个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但在微观上是交替发生；
2. 并行：2个或多个事件在同一时刻同时发生当今的计算机一般都是多核CPU，4核意味着允许4个程序并行进行，但是操作系统的并发性依然必不可少。
3. 共享特性：系统中的资源可供内存中多个并发执行的进程共同使用。
    * 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问。
    * 同时共享方式：允许一个时间段内由多个进程“同时”对他们进行访问。宏观是同时，可能微观是分时共享也可能是同时共享。并发和共享互为存在条件。
4. 虚拟：指把物理上的实体变为若干个逻辑上的对应物。4gb的内存实际可以让远超4gb内存需求的程序同时启用。虚拟存储器技术：空分复用技术（第3章）一个CPU可以同时允许多个程序启动。没有并发性，就谈不上虚拟性。
5. 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。只有系统拥有了并发性，才可能导致系统的异步性。

## 指令

CPU能够识别的最基础的命令；二进制机器语言。
2种指令

* 普通指令
* 特权指令

2种处理器状态

* 用户态
* 核心态

2种程序

* 内核程序：可以执行特权指令及非特权指令
* 应用程序： 只能执行非特权指令

CPU如何识别特权指令：

## 中断

中断的描述

1. 当发生中断时，CPU立刻进入核心态
2. 当中断发生后，当前运行进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同中断信号会有不同处理。
4. 中断是让CPU从用户态转入核心态的唯一指令；核心态-》用户态通过执行特权指令将程序状态字从核心态转为用户态。

中断的分类：

* 内中断
* 外中断

## 系统调用

### 功能

1. 设备管理
2. 文件管理
3. 进程控制
4. 进程通信
5. 内存管理

系统调用和库函数的区别
汇编语言  int x 陷入指令，x调用参数
陷入指令只能执行在用户态

## 进程

### 为什么要引入进程

1.程序段：
2.数据段：
进程产生的原因：为了使参与并发执行的每个程序（含数据）能独立运行，在操作系统中必须为之配专门的数据结构，称之为进程控制块（process control block PCB）。系统利用进程来描述进程的基本情况和活动过程，进行控制和管理。这样由程序块，相关数据段和PCB构成了进程实体。2 进程的特征：a. 动态性b.并发性c.独立性d.异步性

2.进程管理中的数据结构（1）系统资源信息表或进程信息表：包含了资源或进程的标识，描述，状态等信息以及一批指针。通过指针将同类资源或系统进程信息表，或同一进程掌握的资源信息表分类链接成不同队列，便于操作系统进行查找。

为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体店概念；
PCB、程序段、数据段三部分构成了进程实体（进程映像）。
PCB是进程存在的唯一标识。

#### 动态性

1. 进程是程序的一次执行过程；
2. 进程是一个程序及其数据在处理机上顺序执行时发生的活动
3. 进程是具有独立功能的程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位。

引入进程实体的概念后：
进程是进程实体店运行过程，是系统进行资源分配和调度的独立单位。
进程实体是静态的、进程是动态的。

#### PCB包含的内容

1. 进程描述信息：进程标志符PID（进程被创建时，操作系统分配的唯一的ID）、用户标识符UID；
2. 进程控制和管理信息：进程当前状态、进程优先级
3. 资源分配清单：
    * 程序段指针
    * 数据段指针
    * 键盘
    * 鼠标
4. 处理机相关信息：各种寄存器值（当进程切换时需要被进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句）

### 进程的组织

在一个系统中，通常有数十、百、千个PCB。为了能对他们有效管理，应该用适当的方式组织PCB
注：进程的组成讨论的是一个进程内部有由哪些部分构成，组织讨论的是多个进程之间的组织方式。

1. 链接方式（队列）

* 操作系统按进程状态分为多个队列;
* 操作系统持有指向各个队列的指针;

1.2 索引方式（索引表）

* 根据进程状态的不同，建立几张索引表
* 操作系统持有指向各个索引表的指针

### 进程的状态

```mermand
graph process_status
A(三种基本状态)-->B1(运行态(running)：占有CPU，并在CPU上运行)
A(三种基本状态)-->B2(就绪态(ready): 已经具备运行条件，但由于没有空闲CPU，暂时不能运行)
A(三种基本状态)-->B3(阻塞态(waiting/blocked)：因等待某一事件而暂时不能运行)
```

![43bebe7892333333628fcbb0e241ed9b.jpeg](evernotecid://59AADDE0-81CE-49C0-9998-80E54FEA1FF9/appyinxiangcom/23494595/ENResource/p23)

#### 基本状态

1. 运行态(running)：占有CPU，并在CPU上运行;
2. 就绪态(ready): 已经具备运行条件，但由于没有空闲CPU，暂时不能运行;
3. 阻塞态(waiting/blocked)：因等待某一事件而暂时不能运行;

#### 进程的另外2种状态

1. 创建态
在内存中产生pcb、数据段、程序段生成阶段，乘坐创建态
2. 终止态
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

#### 进程状态的转换

![43bebe7892333333628fcbb0e241ed9b.jpeg](.\1_进程状态切换.png)

* 阻塞态无法直接转为就绪态

* 就绪态无法直接转为阻塞态

* 不可修复错误会将进程状态转为终止态

### 进程的特征

1. 动态性：基本特征。
2. 并发性
3. 独立性：独立运行、独立获得资源、独立接受调度的基本单位。
4. 异步性：各进程按各自独立的，不可预知的速度向前推进。
5. 结构性：进程由

### 进程控制

进程控制主要功能是对系统中的各进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

#### 如何实现进程控制

用**原语**实现进程控制。原语的特点是执行期间**不允许中断**，只能一气呵成。这种不可被中断的操作，即原子操作。原语采用**\“关中断指令”\**和“开中断指令”实现。
无论哪种原语，无非做三件事：
1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB，从PCB恢复运行环境)

* 所有的进程控制原语，都会修改进程状态标志；
* 剥夺当前运行进程的CPU使用权必然需要保存其运行环境;
* 某进程开始运行前，必然要恢复其运行间环境
1.2 将PCB插入合适的队列
1.3 分配|回收资源

创建原语：
![avator](./images/1_%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD.png)

撤销原语：
![avator](./images/1_%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD.png)s

阻塞原语和唤醒原语：
![avator](./images/1_%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD%E5%92%8C%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%AD.png)

切换原语:
![avator](./images/1_%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD.png)

### 进程通信

进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间互相独立**。

#### 进程通信--共享存储

1. 基于数据结构的共享：低级
2. 基于存储区的共享:高级，数据形式及存放位置由进程控制；

#### 进程通信--管道通信

管道是指用于连续读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。linux中一个pipe对应的大小为4kb

1. 管道只能采用半双工通信，某一时间段内只能实现单向传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥的访问管道。
3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
4. 如果没有写满，不允许读；如果没有读空，不允许写。
5. 数据一旦被读出，就从管道中丢弃，这就意味着读进程最多只有1个，否则可能会有数据读错的情况。

#### 进程通信--消息传递

1. 进程之间的数据交换以格式化的消息(message)为单位。message=消息头+消息体
2. 进程通过操作系统提供的“发送消息|接受消息”2个原语进行数据交换。
3. 2种方式

* 直接通信方式：消息直接挂到接受方的消息队列里
* 简介(邮箱)通信方式：消息先发到中间体（信箱）

![avator](./images/1_%E8%BF%9B%E7%A8%8B_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

### 线程

#### 为什么要引入线程

有的进程需要在宏观上做很多事，因此引入了进程。

引入线程之后，线程就成了程序执行流的最小单位，是一个基本的CPU执行单元。

![avator](./images/1_%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.png)

#### 线程的属性

1. 线程是处理机调度的单位；
2. 多CPU计算机中，各个线程可占用不同的CPU；
3. 每个线程都有一个线程ID、线程控制块(TCB)；
4. 线程也有就绪、阻塞、运行三个基本状态；
5. 线程几乎不拥有系统资源；
6. 同一进程的不同线程间共享进程的资源；
7. 由于共享内存地址空间，同一进程间的线程通信不需要CPU干预
8. 同一进程中的线程切换，不会引起进程切换，系统开销小；
9. 不同进程中的线程切换，会引起进程切换，系统开销大；


#### 线程的实现方式:

1. 用户级线程(User-level Thread,ULT)

![avator](./images/1_%E7%BA%BF%E7%A8%8B_%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png)

2. 内核级线程(Kernel-Level Thread,KLT)

![avator](./images/1_%E7%BA%BF%E7%A8%8B_%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png)

#### 多线程模型

几个用户级线程映射到几个内核级线程引出该问题：
1. 多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
- 优点：在用户空间即可完成，线程管理开销小，效率高；
- 缺点：当一个用户级线程阻塞后，整个进程都会被阻塞，并发度并不高。多个线程不可在多核处理机上并行进行

2. 一对一模型：一个用户线程对应一个系统线程。每个用户进程拥有与用户级线程同数量的内核级线程
- 优点：一个线程被阻断后，其他线程仍可运行；
- 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，系统开销大。

3. 多对多模型：n用户级线程映射到m个内核级线程(n>=m).
![avator](./images/1_%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B_%E5%A4%9A%E5%AF%B9%E5%A4%9A.png)


## 内存
![avator](./images/3_%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)

### 基本分页存储管理的基本概念
连续分配管理方式：为进程分配的必须是一个连续的内存空间；
非连续分配管理方式：为进程分配的可以是非连续的内存空间；


### 逻辑地址转物理地址到基本参数：
1. 逻辑地址到页号；
2. 逻辑地址对应的页内偏移量
3. 逻辑地址对应的页面在内存中存放的地址。

![avator](./images/3_OS%E4%B8%AD%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%A8%A1%E5%9E%8B.png)
基本地址转换机构可以借助**进程的页表**将逻辑地址转换为物理地址.每一页的都是一个页表项(页表项=页号+块号)
通常会在系统中设置一个页表寄存器(PTR),存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的地址
![avator](./images/3_%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png)
1. 算出逻辑地址对应的页号；
2. 算出该页号对应页面在内存中的偏移量：操作系统会给每个进程的页面用某种数据结构保存其起始位置(PTR)
3. 算出逻辑地址在页面中的偏移量；
4. 物理地址=页面地址+页内便宜量。

- 操作系统会把**页面大小**一般设置为2的整数幂，方便计算页号和页面偏移量。（内存位置共32位：前20位表示页号，后12位表示页内偏移量)
![avator](./images/3_OS%E5%86%85%E5%AD%98%E9%A1%B5%E9%83%BD%E4%B8%BA2%E7%9A%84%E5%B9%82%E7%9A%84%E5%8E%9F%E5%9B%A0.png)
- 如果每个页面大小为2^k byte(8bits),则末尾k位为页内偏移量，其余部分为页号。
- 在操作系统中每个页表项的长度是相同的，块号可以通过计算得知：
```内存块个数=物理内存大小/页面大小
   内存位置表示需要字节数=内存块个数
   假设为3byte
   如果1个进程由n个页面组成，则该进程的页表总共会占3*n个字节
```
### 基本地址变换机构：用于实现逻辑地址到物理地址到一组**硬件**机构
基本地址变换机构可以借助进程的页表将逻辑地址转为物理地址。
通常会在系统中设置一个**页表寄存器(PTR)**，存放页表在内存中的**起始地址F和页表长度M**。进程未执行时，页表的起始位置和页表长度**放在进程控制块中(PCB)**.当进程被调度时，操作系统内核会把它们放到**页表寄存器**中。
注意：页面大小是2的整数幂。
设页面大小为L，逻辑地址A到物理地址E的变换过程如下:
![avator](./images/3_%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png)
1. 计算机内存区域=系统区+用户区；系统区包含了程序控制块(PCB)记录了进程所有信息,进程未执行时包含页表的其实位置和页表长度;
2. 先计算页号P和页内偏移量W，如果用10进制换算(P=A/L,W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快的得到二进制表示的页号、页内偏移量)
3. 先用页号去查询PTR中的页表长度M，查询页号是否合法（页号>=M时非法)；如非法，则报越界异常；如合法，到第4步
4. 依据PTR中的页表起始地址，查询页表，找到页号对应的页表项，确定内存块号；
4. 以内存块号和页内偏移量得到物理地址：E=b*L+W; b:内存块号；L：页面长度；W：页内偏移量。对于计算机来说只用把内存块号b、页面偏移量W用二进制表示，拼接起来就是最终物理地址了。

几个基本概念：
- 页表项长度： 每个页表项占多大的存储空间
- 页表长度： 页面中有几个页表项，即有几页
- 页面大小L：一个页面占多大的存储空间，由操作系统决定；
- 逻辑地址A

#### 总结
在分页存储管理系统中(页式管理)，只要确定了每个页面大小，逻辑地址结构就确定了，因此，**页式地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动算出页号、页内偏移量 2个部分。并不需要显示告诉系统这个逻辑地址中，页内偏移量占多少位。

#### 对页表项大小的进一步探讨
理论上，页表项长度为3b即可表示内存块号的范围，但是为了方便页表的查询，常常会让页表项多占更多的字节，使得每个页面恰好可以装得下整个页表项，避免产生碎片。
![avator](./images/3_%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%AE%9E%E9%99%85%E4%B8%8E%E7%90%86%E8%AE%BA.png)

### 局部性原理
时间局部性：如果执行了某条指令，切不久后这条指令很有可能再次执行，如果某个数据被访问过，不久后该数据可能被再次访问。例如循环。
空间局部性：如果程序访问了某个存储单元，在不久之后，其附近的存储单元页可能被再次访问。例如：数组结构的数据。

使用基本地址变换机构中，每次都要访问一个逻辑地址，都需要查询内存中的页表，由于局部性原理，可能连续多次查到的都是同一个页表中的页表项。既然如此，可以利用局部性特性减少访问页表的次数。

#### 什么是快表(TLB)
快表，又称联想寄存器(TLB),是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程，与此对应，内存中的页表常称为慢表。
1. 快表的访问逻辑
![avator](./images/3_%E5%BF%AB%E8%A1%A8%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91.png)
2. 快表的更新逻辑：
在慢表中找到页表项后，应同时将其存入快表，以便之后的访问；
如果快表已满，则必须按**一定的算法**对旧的页表进行替换。

总结：
![avator](./images/3_%E5%BF%AB%E8%A1%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)

### 两级页表
#### 单极页表存在的问题
一个支持32位逻辑地址，采用分页存储管理，页面大小为4kb，页表项长度为4b。
4kb=2^12B,因此页内地址要用12位表示，生于20位表示页号。
因此，该系统中用户进程最多有2^20页，相应的，一个进程的页表中，最多会有2^20=1M=1048576个页表项。所以一个页表最大需要2^20*4B.所以一个页表最大需要2^20*4B=2^22B的空间。
需要2^22/2^12= 2^10个页框存储页表。

根据页号查询页表的方法：K号页对应的页表项存放位置=页表起始位置+K*4。
因此要所有的页表项连续存放的基础上才能实现。
比较占空间，也丧失了离散存放的优点。

#### 解决方案
将页表进行分组，使每个内存块刚好可以放入1个分组(比如上述例子中，页面大小4KB，每个页表项4B，每个页面可以存放1K个页表项，因此每1K个页表项为1组，刚好可以放入一个内存块。再将各组离散放到各个内存块中。)
另外，要为离散分配的页表再建立一张页表，称为页目录表，或外层页表，顶层页表。

二级页表的地址转换方示意图:
![avator](./images/3_%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)

PS：若想访问的页面不在内存中，则产生缺页中断(内中断)，然后将目标页面从外存调入内存。
1. 若采用多级页表机制，则各级页表的大小不能超过一个页面。
2. 2级页表的访存次数分析(假设不存在快表)：
第一次访存：访问内存中的页目录表；
第二次访存：访问内存中的二级页表
第三次访存：访问目标单元。


![avator](./images/3_2%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)
newK5BRgFKV

### 基本分段存储管理

#### 什么是分段
进程的地址空间，会按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。
分段系统中逻辑地址=段号+段内地址
- 段号的位数：决定每个进程最多可以有几个段
- 段内地址位数：决定了每个段段最大长度
#### 什么是段表
段表：记录各个逻辑段在内存中存放的位置；类似于页表
段表=段号(隐藏不占空间)+段长+基址
1.每个段对应一个段表项，其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。
2.各个段表项的长度相同。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为(段号16位，段内地址16位)，因此用16位即可表示最大段长。物理内存大小为4GB(可用32位表示整个物理内存地址空间)。因此，可以让每个段表项占16+32=48位，即6B。由于段表项长度相同，因此段号可以隐藏，不占存储空间。
若段表存放的起始位置为M，则K号段对应的段表项存放的地址为M+K*6
#### 如何实现地址变换
![avator](./images/3_%E6%AE%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)

需要进行2次越界检查：段号越界；段长越界
#### 分段、分页管理的对比

页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的。**
段是信息的逻辑单位。分段的主要目的是为了更好的满足用户需求，方便编程。一个段通常包含着一组属于一个逻辑块的信息。分段是对用户可见的，用户编程时需要显示地给出段名。
页的大小是固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。
分段的用户进程地址是2维的，需要给出段名+段内地址。例如load 1，<A>；

分段比分页更容易实现信息共享和保护。

![avator](./images/3_%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)